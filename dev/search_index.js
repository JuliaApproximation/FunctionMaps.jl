var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API-Reference","page":"Public API Reference","title":"Public API Reference","text":"","category":"section"},{"location":"api/#Constants","page":"Public API Reference","title":"Constants","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:constant]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#Functions","page":"Public API Reference","title":"Functions","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:function]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#FunctionMaps.affinematrix-Tuple{FunctionMaps.AbstractAffineMap}","page":"Public API Reference","title":"FunctionMaps.affinematrix","text":"Return the matrix A in the affine map Ax+b.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.affinevector-Tuple{FunctionMaps.AbstractAffineMap}","page":"Public API Reference","title":"FunctionMaps.affinevector","text":"Return the vector b in the affine map Ax+b.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.canonicalmap-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.canonicalmap","text":"canonicalmap([ctype::CanonicalType, ]map)\n\nReturn an associated canonical map, if any, of the given map.\n\nOptionally, a canonical type argument may specify an alternative canonical map. Canonical maps help with converting between equal maps of different types.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.codomaintype-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.codomaintype","text":"codomaintype(m[, T])\n\nWhat is the type of a point in the codomain of the function map m?\n\nThe second argument optionally specifies a domain type T.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.diffvolume-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.diffvolume","text":"diffvolume(m[, x])\n\nCompute the differential volume (at a point x). If J is the Jacobian matrix, possibly rectangular, then the differential volume is sqrt(det(J'*J)).\n\nIf the map is square, then the differential volume is the absolute value of the Jacobian determinant.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.domaintype-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.domaintype","text":"domaintype(m)\n\nWhat is the expected type of a point in the domain of the function map m?\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.factor-Tuple{Any, Vararg{Any}}","page":"Public API Reference","title":"FunctionMaps.factor","text":"Factor I... of a product-like composite object.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.factors","page":"Public API Reference","title":"FunctionMaps.factors","text":"Factors of a product-like composite object (equivalent to components(d)).\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionMaps.inverse-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.inverse","text":"inverse(m[, x])\n\nReturn the inverse of m. The two-argument function evaluates the inverse at the point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.isaffinemap-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.isaffinemap","text":"isaffinemap(m)\n\nIs m an affine map?\n\nIf m is affine, then it has the form m(x) = A*x+b.\n\nSee also: affinematrix, affinevector.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.isequalmap-Tuple{Any, Any}","page":"Public API Reference","title":"FunctionMaps.isequalmap","text":"isequalmap(map1, map2)\n\nAre the two given maps equal?\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.islinearmap-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.islinearmap","text":"islinearmap(m)\n\nIs m a linear map?\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.isrealmap-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.isrealmap","text":"isrealmap(m)\n\nIs the map real-valued?\n\nA map is real-valued if both its domain and codomain types are real.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.jacdet-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.jacdet","text":"jacdet(m[, x])\n\nReturn the determinant of the jacobian as a map. The two-argument version evaluates the jacobian determinant at a point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.jacobian-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.jacobian","text":"jacobian(m[, x])\n\nReturn the jacobian map. The two-argument version evaluates the jacobian at a point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.leftinverse-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.leftinverse","text":"leftinverse(m[, x])\n\nReturn a left inverse of the given map. This left inverse mli is not unique, but in any case it is such that (mli ∘ m) * x = x for each x in the domain of m.\n\nThe two-argument function applies the left inverse to the point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.mapsize","page":"Public API Reference","title":"FunctionMaps.mapsize","text":"mapsize(m[, i])\n\nThe size of a vectorvalued map is the size of its jacobian matrix.\n\nA map with size (3,5) maps vectors of length 5 to vectors of length 3. Its jacobian matrix is a 3-by-5 matrix.\n\nOptionally, similar to the size function, a second argument i can be provided. Choose i to be 1 or 2 to return only the corresponding element of the size. The dimension of the domain type is mapsize(m, 2), while that of the codomain type is mapsize(m, 1).\n\nIf a map is scalar valued, its mapsize equals (). This reflects the convention in Julia that the size of a number is an empty tuple: size(5) == (). If a map is scalar-to-vector, its mapsize is the tuple (m,) of length one. In this case the jacobian is a vector with size (m,). If a map is vector-to-scalar, its mapsize is (1,n).\n\nThus, in all cases of scalarvalued and vectorvalued maps, the mapsize of a map agrees with the size of the Jacobian matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#FunctionMaps.nfactors-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.nfactors","text":"The number of factors of a product-like composite object.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.numtype-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.numtype","text":"The numeric element type of x in a Euclidean space.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.prectype-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.prectype","text":"prectype(x[, ...])\n\nThe floating point precision type associated with the argument(s).\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.rightinverse-Tuple{Any}","page":"Public API Reference","title":"FunctionMaps.rightinverse","text":"rightinverse(m[, x])\n\nReturn a right inverse of the given map. This right inverse mri is not unique, but in any case it is such that (m ∘ mri) * y = y for each y in the range of m.\n\nThe two-argument function applies the right inverse to the point x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Types","page":"Public API Reference","title":"Types","text":"","category":"section"},{"location":"api/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:type]\nPublic  = true\nPrivate = false","category":"page"},{"location":"api/#FunctionMaps.AffineMap","page":"Public API Reference","title":"FunctionMaps.AffineMap","text":"AffineMap{T} <: AbstractAffineMap{T}\n\nThe supertype of all affine maps that store `A` and `b`.\n\nConcrete subtypes differ in how A and b are represented.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.AffineMap-Tuple{Number, Number}","page":"Public API Reference","title":"FunctionMaps.AffineMap","text":"AffineMap(A, b)\n\nReturn an affine map with an appropriate concrete type depending on the arguments A and b.\n\nExamples\n\njulia> AffineMap(2, 3)\nx -> 2 * x + 3\n\n\n\n\n\n","category":"method"},{"location":"api/#FunctionMaps.ConstantMap","page":"Public API Reference","title":"FunctionMaps.ConstantMap","text":"The supertype of constant maps from T to U.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.IdentityMap","page":"Public API Reference","title":"FunctionMaps.IdentityMap","text":"Supertype of identity maps.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.LinearMap","page":"Public API Reference","title":"FunctionMaps.LinearMap","text":"LinearMap{T} <: AbstractAffineMap{T}\n\nThe supertype of all linear maps y = A*x.\n\nConcrete subtypes may differ in how A is represented.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.Map","page":"Public API Reference","title":"FunctionMaps.Map","text":"A Map{T} is a map of a single variable of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.MapRef","page":"Public API Reference","title":"FunctionMaps.MapRef","text":"MapRef(m)\n\nA reference to a map.\n\nIn a function call, MapRef(x) can be used to indicate that x should be treated as a map, e.g., foo(x, MapRef(m)).\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.ProductMap","page":"Public API Reference","title":"FunctionMaps.ProductMap","text":"A product map is diagonal and acts on each of the components of x separately: y = f(x) becomes y_i = f_i(x_i).\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.Translation","page":"Public API Reference","title":"FunctionMaps.Translation","text":"A Translation represents the map y = x + b.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.UnityMap","page":"Public API Reference","title":"FunctionMaps.UnityMap","text":"The unity map f(x) = 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunctionMaps.ZeroMap","page":"Public API Reference","title":"FunctionMaps.ZeroMap","text":"The zero map f(x) = 0.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Internal-API-Reference","page":"Internal API Reference","title":"Internal API Reference","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"This is an exhaustive list of all non-exported constants, types and functions in FunctionMaps.jl.","category":"page"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"warning: Warning\nUnexported functions and types are subject to change across different releases of the package, even if the release is said to be non-breaking.","category":"page"},{"location":"internal/#Constants","page":"Internal API Reference","title":"Constants","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:constant]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#FunctionMaps.AnyMap","page":"Internal API Reference","title":"FunctionMaps.AnyMap","text":"AnyMap is the union of Map and MapRef.\n\nIn both cases map(m::AnyMap) returns the map itself.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Functions","page":"Internal API Reference","title":"Functions","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:function]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#FunctionMaps.affine_composition-Tuple{FunctionMaps.AbstractAffineMap, FunctionMaps.AbstractAffineMap}","page":"Internal API Reference","title":"FunctionMaps.affine_composition","text":"Compute the affine map that represents map2 after map1, that is: y = a2*(a1*x+b1)+b2 = a2*a1*x + a2*b1 + b2.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.bounded_interval_map-NTuple{4, Any}","page":"Internal API Reference","title":"FunctionMaps.bounded_interval_map","text":"Like interval_map, but guaranteed to return a scalar affine map.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.canonicalextensiontype-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.canonicalextensiontype","text":"Return the extension type associated with the given object.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.checkmap-Tuple{Map}","page":"Internal API Reference","title":"FunctionMaps.checkmap","text":"checkmap(m)\n\nChecks that m is a map or refers to a map and if so returns that map, throws an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_domaintype-Union{Tuple{T}, Tuple{Type{T}, Map{T}}} where T","page":"Internal API Reference","title":"FunctionMaps.convert_domaintype","text":"convert_domaintype(T, m)\n\nConvert the given map to a map such that its domaintype is T.\n\nSee also: domaintype.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_eltype-Union{Tuple{T}, Tuple{Type{T}, AbstractArray}} where T","page":"Internal API Reference","title":"FunctionMaps.convert_eltype","text":"convert_eltype(T, x)\n\nConvert x such that its eltype equals T.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_fromcartesian-Union{Tuple{DIM}, Tuple{AbstractVector, Val{DIM}}} where DIM","page":"Internal API Reference","title":"FunctionMaps.convert_fromcartesian","text":"Convert a vector from a cartesian format to a nested tuple according to the given dimensions.\n\nFor example: convert_fromcartesian([1,2,3,4,5], Val{(2,2,1)}()) -> ([1,2],[3,4],5)\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_numtype-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"FunctionMaps.convert_numtype","text":"convert_numtype(T, x)\n\nConvert x such that its numtype equals T.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_prectype-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"FunctionMaps.convert_prectype","text":"convert_prectype(T, x)\n\nConvert x such that its prectype equals T.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.convert_tocartesian-Union{Tuple{DIM}, Tuple{Any, Val{DIM}}} where DIM","page":"Internal API Reference","title":"FunctionMaps.convert_tocartesian","text":"The inverse function of convert_fromcartesian.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.euclideandimension-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"Internal API Reference","title":"FunctionMaps.euclideandimension","text":"What is the euclidean dimension of the given type (if applicable)?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.functionmap-Tuple{Map}","page":"Internal API Reference","title":"FunctionMaps.functionmap","text":"functionmap(m)\n\nReturn a map associated with the object m.\n\nThe result need not have type Map, but its MapStyle is IsMap.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.glm_domaintype-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.glm_domaintype","text":"What is the suggested domaintype for a generic linear map A*x with the given argument 'A'?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.hascanonicalmap-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.hascanonicalmap","text":"Does the map have a canonical map?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.hashrec-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.hashrec","text":"Apply the hash function recursively to the given arguments.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.identitymatrix-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.identitymatrix","text":"Return an identity matrix with the same size as the map.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.interval_map-NTuple{4, Any}","page":"Internal API Reference","title":"FunctionMaps.interval_map","text":"Map the interval [a,b] to the interval [c,d].\n\nThis function deals with infinite intervals, and the type of the map returned may depend on the value (finiteness) of the given endpoints.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.issquaremap-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.issquaremap","text":"Is the given map a square map?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.isvectorvalued-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.isvectorvalued","text":"Is the map a vector-valued function, i.e., a function from Rn to Rm?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promotable_eltypes-Tuple","page":"Internal API Reference","title":"FunctionMaps.promotable_eltypes","text":"Are the given element types promotable to a concrete supertype?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promotable_maps-Tuple","page":"Internal API Reference","title":"FunctionMaps.promotable_maps","text":"Can the maps be promoted to a common domain type without throwing an error?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promote_map_point_pair-Tuple{Any, Any}","page":"Internal API Reference","title":"FunctionMaps.promote_map_point_pair","text":"Promote map and point to compatible types.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promote_maps-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.promote_maps","text":"Promote the given maps to have a common domain type.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promote_numtype-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.promote_numtype","text":"promote_numtype(a, b[, ...])\n\nPromote the numeric types of the arguments to a joined supertype.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.promote_prectype-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.promote_prectype","text":"promote_prectype(a, b[, ...])\n\nPromote the precision types of the arguments to a joined supertype.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.simplifies-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.simplifies","text":"simplifies(m)\n\nDoes the map simplify?\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.simplify-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.simplify","text":"simplify(m)\n\nSimplify the given map to an equal map.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.to_matrix-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"FunctionMaps.to_matrix","text":"to_matrix(T, A[, b])\n\nConvert the A in the affine map A*x or A*x+b with domaintype T to a matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.to_numtype-Union{Tuple{U}, Tuple{T}, Tuple{Type{U}, Type{T}}} where {T, U}","page":"Internal API Reference","title":"FunctionMaps.to_numtype","text":"to_numtype(U, T)\n\nReturn the type to which T can be converted, such that the numtype becomes U.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.to_prectype-Union{Tuple{U}, Tuple{T}, Tuple{Type{U}, Type{T}}} where {T, U}","page":"Internal API Reference","title":"FunctionMaps.to_prectype","text":"to_prectype(U, T)\n\nReturn the type to which T can be converted, such that the prectype becomes U.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.to_vector-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"FunctionMaps.to_vector","text":"to_vector(::Type{T}, A[, b])\n\nConvert the b in the affine map A*x or A*x+b with domaintype T to a vector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.tofunctionmap-Tuple{Map}","page":"Internal API Reference","title":"FunctionMaps.tofunctionmap","text":"Convert the given map to a map defined in FunctionMaps.jl.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.zeromatrix-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.zeromatrix","text":"Return a zero matrix of the same size as the map.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.zerovector-Tuple{Any}","page":"Internal API Reference","title":"FunctionMaps.zerovector","text":"Return a zero vector of the same size as the codomain of the map.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Types","page":"Internal API Reference","title":"Types","text":"","category":"section"},{"location":"internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [FunctionMaps]\nOrder   = [:type]\nPublic  = false\nPrivate = true","category":"page"},{"location":"internal/#FunctionMaps.AbsMap","page":"Internal API Reference","title":"FunctionMaps.AbsMap","text":"An AbsMap returns the absolute value of the result of a given map.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.AbstractAffineMap","page":"Internal API Reference","title":"FunctionMaps.AbstractAffineMap","text":"AbstractAffineMap{T} <: Map{T}\n\nAn affine map has the general form y = A*x + b.\n\nWe use affinematrix(m) and affinevector(m) to denote A and b respectively. Concrete subtypes include linear maps of the form y = A*x and translations of the form y = x + b.\n\nSee also: affinematrix, affinevector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.AngleMap","page":"Internal API Reference","title":"FunctionMaps.AngleMap","text":"AngleMap is a left inverse of UnitCircleMap. A 2D vector x is projected onto the intersection point with the unit circle of the line connecting x to the origin. The angle of this point, scaled to the interval [0,1), is the result.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.CanonicalExtensionType","page":"Internal API Reference","title":"FunctionMaps.CanonicalExtensionType","text":"CanonicalExtensionType <: CanonicalType\n\nCanonical types used to translate between packages.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.CanonicalType","page":"Internal API Reference","title":"FunctionMaps.CanonicalType","text":"Supertype of different kinds of canonical objects.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.CartToPolarMap","page":"Internal API Reference","title":"FunctionMaps.CartToPolarMap","text":"A Cartesion to Polar map. First dimension is interpreted as radial distance, second as an angle. The unit circle is mapped to the square [-1,1]x[-1,1].\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.ComplexToVector-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.ComplexToVector","text":"ComplexToVector()\nComplexToVector{T}()\n\nMap a complex number a+bi to the length 2 vector a b.\n\nSee also: VectorToComplex.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.ComposedMap","page":"Internal API Reference","title":"FunctionMaps.ComposedMap","text":"ComposedMap{T,MAPS}\n\nThe composition of several maps.\n\nThe components of a ComposedMap are the maps in the order that they are applied to the input.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.CompositeLazyMap","page":"Internal API Reference","title":"FunctionMaps.CompositeLazyMap","text":"A composite lazy map is defined in terms of several other maps.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.DerivedMap","page":"Internal API Reference","title":"FunctionMaps.DerivedMap","text":"A DerivedMap inherits all of its properties from another map, but has its own type.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.DeterminantMap","page":"Internal API Reference","title":"FunctionMaps.DeterminantMap","text":"A DeterminantMap returns the determinant of the result of a given map.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.DynamicIdentityMap","page":"Internal API Reference","title":"FunctionMaps.DynamicIdentityMap","text":"Identity map with dynamic size determined by a dimension field.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.Equal","page":"Internal API Reference","title":"FunctionMaps.Equal","text":"Equal <: CanonicalType\n\nA canonical object that is equal but simpler.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.Equivalent","page":"Internal API Reference","title":"FunctionMaps.Equivalent","text":"Equivalent <: CanonicalType\n\nA canonical object that is equivalent but may have different type.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.FixedConstantMap","page":"Internal API Reference","title":"FunctionMaps.FixedConstantMap","text":"The constant map f(x) = c.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.FlatToNested","page":"Internal API Reference","title":"FunctionMaps.FlatToNested","text":"Map a flattened vector to a nested one.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.GenericAffineMap","page":"Internal API Reference","title":"FunctionMaps.GenericAffineMap","text":"An affine map for any combination of types of A and b.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.GenericLinearMap","page":"Internal API Reference","title":"FunctionMaps.GenericLinearMap","text":"A GenericLinearMap is a linear map y = A*x for any type of A.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.GenericTranslation","page":"Internal API Reference","title":"FunctionMaps.GenericTranslation","text":"Translation by a generic vectorlike object.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.IsMap","page":"Internal API Reference","title":"FunctionMaps.IsMap","text":"IsMap()\n\nindicates an object implements the map interface.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.Isomorphism","page":"Internal API Reference","title":"FunctionMaps.Isomorphism","text":"Isomorphism{T,U} <: TypedMap{T,U}\n\nAn isomorphism is a bijection between types that preserves norms.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.LazyDiffVolume","page":"Internal API Reference","title":"FunctionMaps.LazyDiffVolume","text":"A lazy volume element evaluates to diffvolume(m, x) on the fly.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.LazyInverse","page":"Internal API Reference","title":"FunctionMaps.LazyInverse","text":"A lazy inverse stores a map m and returns inverse(m, x).\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.LazyJacobian","page":"Internal API Reference","title":"FunctionMaps.LazyJacobian","text":"A lazy Jacobian J stores a map m and returns J(x) = jacobian(m, x).\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.LazyMap","page":"Internal API Reference","title":"FunctionMaps.LazyMap","text":"A lazy map has an action that is defined in terms of other maps. Those maps are stored internally, and the action of the lazy map is computed on-the-fly and only when invoked.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.MapStyle","page":"Internal API Reference","title":"FunctionMaps.MapStyle","text":"MapStyle(m)\n\nTrait to indicate whether or not m implements the map interface.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.MulMap","page":"Internal API Reference","title":"FunctionMaps.MulMap","text":"The lazy multiplication of one or more maps.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.NestedToFlat","page":"Internal API Reference","title":"FunctionMaps.NestedToFlat","text":"Map a nested vector or tuple to a flat vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.NotMap","page":"Internal API Reference","title":"FunctionMaps.NotMap","text":"NotMap()\n\nindicates an object does not implement the Map interface.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.NumberToVector-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.NumberToVector","text":"NumberToVector()\nNumberToVector{T}()\n\nMap a number x to the length 1 vector [x].\n\nSee also: VectorToNumber.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.PolarToCartMap","page":"Internal API Reference","title":"FunctionMaps.PolarToCartMap","text":"A Polar to Cartesian map. The angle is mapped to the second dimension, radius to the first. The square [-1,1]x[-1,1] is mapped to the unit circle.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.ScalarAffineMap","page":"Internal API Reference","title":"FunctionMaps.ScalarAffineMap","text":"An affine map with scalar representation.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.ScalarLinearMap","page":"Internal API Reference","title":"FunctionMaps.ScalarLinearMap","text":"A ScalarLinearMap is a linear map y = A*x for scalars.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.ScalarTranslation","page":"Internal API Reference","title":"FunctionMaps.ScalarTranslation","text":"Translation by a scalar value.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.SimpleLazyMap","page":"Internal API Reference","title":"FunctionMaps.SimpleLazyMap","text":"A simple lazy map derives from a single other map.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.StaticAffineMap","page":"Internal API Reference","title":"FunctionMaps.StaticAffineMap","text":"An affine map with representation using static arrays.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.StaticIdentityMap","page":"Internal API Reference","title":"FunctionMaps.StaticIdentityMap","text":"The identity map for variables of type T.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.StaticLinearMap","page":"Internal API Reference","title":"FunctionMaps.StaticLinearMap","text":"A StaticLinearMap is a linear map y = A*x using static arrays.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.StaticTranslation","page":"Internal API Reference","title":"FunctionMaps.StaticTranslation","text":"Translation by a static vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.SumMap","page":"Internal API Reference","title":"FunctionMaps.SumMap","text":"The lazy sum of one or more maps.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.TupleProductMap","page":"Internal API Reference","title":"FunctionMaps.TupleProductMap","text":"A TupleProductMap is a product map with all components collected in a tuple. There is no vector-valued function associated with this map.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.TupleToVector","page":"Internal API Reference","title":"FunctionMaps.TupleToVector","text":"Map a tuple to a static vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.TypedMap","page":"Internal API Reference","title":"FunctionMaps.TypedMap","text":"Any instance of TypedMap{T,U} maps a variable of type T to a variable of type U.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.UnitCircleMap","page":"Internal API Reference","title":"FunctionMaps.UnitCircleMap","text":"The map [cos(2πt), sin(2πt)] from [0,1] to the unit circle in ℝ^2.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.UnitDiskMap","page":"Internal API Reference","title":"FunctionMaps.UnitDiskMap","text":"The map r*[cos(2πt), sin(2πt)] from [0,1]^2 to the unit disk in ℝ^2.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VcatMap","page":"Internal API Reference","title":"FunctionMaps.VcatMap","text":"A VcatMap is a product map with domain and codomain vectors concatenated (vcat) into a single vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VectorAffineMap","page":"Internal API Reference","title":"FunctionMaps.VectorAffineMap","text":"An affine map with array and vector representation.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VectorLinearMap","page":"Internal API Reference","title":"FunctionMaps.VectorLinearMap","text":"A VectorLinearMap is a linear map y = A*x using vectors and matrices.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VectorProductMap","page":"Internal API Reference","title":"FunctionMaps.VectorProductMap","text":"A VectorProductMap is a product map where all components are univariate maps, with inputs and outputs collected into a Vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VectorToComplex-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.VectorToComplex","text":"VectorToComplex()\nVectorToComplex{T}()\n\nMap a length 2 vector ab to the complex number a+bi.\n\nSee also: ComplexToVector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.VectorToNumber-Tuple{}","page":"Internal API Reference","title":"FunctionMaps.VectorToNumber","text":"VectorToNumber()\nVectorToNumber{T}()\n\nMap a length 1 vector x to the number x[1].\n\nSee also: NumberToVector.\n\n\n\n\n\n","category":"method"},{"location":"internal/#FunctionMaps.VectorToTuple","page":"Internal API Reference","title":"FunctionMaps.VectorToTuple","text":"Map a static vector to a tuple.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.VectorTranslation","page":"Internal API Reference","title":"FunctionMaps.VectorTranslation","text":"Translation by a vector.\n\n\n\n\n\n","category":"type"},{"location":"internal/#FunctionMaps.WrappedMap","page":"Internal API Reference","title":"FunctionMaps.WrappedMap","text":"A WrappedMap{T} takes any object and turns it into a Map{T}.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FunctionMaps","category":"page"},{"location":"#FunctionMaps","page":"Home","title":"FunctionMaps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation for FunctionMaps.","category":"page"},{"location":"#What-is-FunctionMaps.jl","page":"Home","title":"What is FunctionMaps.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FunctionMaps.jl is a package designed to represent scalar- and vector-valued functions. It makes it easy to make new maps from existing ones, via composition or by taking products.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started, have a look at the examples or browse the API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is a work in progress.","category":"page"}]
}
